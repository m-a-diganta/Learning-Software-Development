"""OOP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZPycNFnbu3k-ZugL8PrkZanlURtVZVkg

*   Class - Blueprint ( Template for making objects)
*   Object - real entity or **instance** of Class
*   Objects - Variables of the type class
*   Attribute - variables
*   Method - Functions
*   If 4 objects created - constructor called 4 times
*   **Constructor** creates the object from class design
*   **Constructor** is basically the init function that is by default called even if dont introduce it
"""

class InstagramUser:
    def __init__(self,name,id,acc_type="Public"):
        self.name=name
        self.id=id
        self.acc_type=acc_type
    def showInfo(self):
        print(f"User name: {self.name} ")
        print(f"User ID: {self.id} ")
        print(f"Account type: {self.acc_type} ")
    def viewStory(self,*obj):
        for i in obj:
            if i.acc_type=="Public":
                print(f"{self.name}, you can view {i.name}'s story. ")
            else:
                print(f"{self.name}, you cannot view {i.name}'s story. ")
    def changeAccountType(self):
        if self.acc_type=="Public":
            self.acc_type="Private"
        else:
            self.acc_type="Public"
        return "Account type changed. "

user1 = InstagramUser("Dwayne Johnson", "therock")
print("1====================================")
user1.showInfo()
print("2====================================")
user2 = InstagramUser("Anne", "anne123", "Private")
print("3====================================")
user3 = InstagramUser("Joy", "thetravellerjoy", "Private")
print("4====================================")
user3.showInfo()
print("5====================================")
user2.viewStory(user1, user3)
print("6====================================")
print(user3.changeAccountType())
print("7====================================")
user3.showInfo()
print("8====================================")
user2.viewStory(user3)

class Car:
    #print("Object created")
    color ="Blue"
    brand="Mercedes"
car1=Car()
print(car1)
print(car1.color)
print(car1.brand)

# Non-parameterized constructor

class Employee:
    pass

emp1=Employee()
emp2=Employee()

# Non-parameterized/default constructor

class Employee:
  def __init__(self):   # deafult constructor
    print(self)
    print("Emplyee object created")

emp1=Employee()  # called for object 1
emp2=Employee()  # called for object 2

# Parameterized constructor

class Employee:

  def __init__(self, name):   # Parameterized constructor
    self.name=name  # Instance variable
    print(self.name, "created")
    print(name, "created")

emp1=Employee("John")    # Instance/object 1
emp2=Employee("David")   # Instance/object 2
print(emp2.name)

"""Instance Method - cant be called before creating an object and takes self keyword"""

# How Instance method works

class Employee:

  def __init__(self, name, no):   # Parameterized constructor
    self.name=name  # Instance variable
    self.id = no  #instance variable

  #Instance method
  def display(self):
    print(self.name,self.id)


emp1=Employee("John",11)    # Instance/Object 1
emp2=Employee("David",12)   # Instance/Object 1

emp1.display()
emp2.display()

"""**Practice**"""

class Student:
    pass

s1=Student() # Object is created with default/built-in constructor
print(s1)  # prints where the object is stored in RAM

# how default constructor works

class Student:
    # constructor method automatically gets called 1 time
    # But for instance methods, we need to call them
    def __init__(self):
        print(self)  # here self = instance "s1", we can see from the print
        print("A student object created")

s1=Student()
print(s1)
print("---------------------------------------------------------------------")

s2=Student()

# how parameterized constructor works

class Student:
    def __init__(self,string,number):
        self.name = string
        self.id = number
        print("A student object created")

s1=Student("Bob",11)
print("Address of s1: ",s1)
print("---------------------------------------------------------------------")

s2=Student("Abid",12)
print("Address of s2: ",s2)  # Notice the addresses are always different for different object
print("---------------------------------------------------------------------")

#print(name)
print(s1.name)
print(s2.name)

print(s1.id)
s1.id=20
print(s1.id)

from re import S
# How instance methods work

class Student:
    def __init__(self,string,number):
        self.name = string
        self.id = number
        #print("A student object created")
    def details(self):
        print("name:", self.name)
        print("ID:", self.id)

s1=Student("Bob",11)
s1.details()
print("---------------------------------------------------------------------")
s1.id=22
s1.details()
print("---------------------------------------------------------------------")
s2=Student("Ahil",10)
print(s2.details)
s2.details()

del s1.id   # How do delete the object or it's attributes
#print(s1.id)
del s1
#print(s1)

class House:
    def __init__(self):
        self.window=4
        self.door=2

    def view(self):
        print(self.window, "windows")
        print(self.door, "doors")

h1=House()
h1.view()
print("------------------------------------------")
h2=House()
h2.view()
print("--------------------------------------------")
h2.door=5
h2.window=8
h2.view()

# instance variables are basically the attributes of objects
class Car:
    country = "US"  # Class attribute - same for each object
    wheel=2 # class attribute < object attribute
    def __init__(self,name,model):
        self.name= name  #Instance variable / Object's Attribute
        self.year=model    #Instance variable
        self.wheel= 4     #Instance variable (not taken as argument)
    def view(self):   #instance method
        print("Model year of",self.name,"is",self.year)
        print("It's a",self.wheel,"wheel car")

c1=Car("BMW", 2016)
print(c1.wheel)   # shouldnt print the class attribute
print(c1.country)
c1.view()

c2=Car("Audi", 2020)
print(c2.wheel)
print(c2.country)
c2.view()

print("-----------------------------------------------------------")
print(c1.__dict__) # shows attributes of an particular object in Dictionary
print(dir(c1)) # prints alll attributes and methods of an object in a list

class Book:
    def __init__(self, name, author):
        self.name = name
        self.author = author
        self.price = 0
        print("Wanna buy this book?")
    def update_price(self,price):
        self.price=price
    def get_price(self):
        return self.price
    def details(self):
        print("Book name:", self.name)
        print("Book Author:", self.author)
        print("Book price:", self.price)
    def compare(self,other_object):  # can access another object's attributes
        if self.name == other_object.name:
            print("Names are the same")
        else:
            print("Names are different")
        if self.price == other_object.price:
            print("Prices are the same")
        else:
            print("Prices are different")
        if self.author == other_object.author:
            print("Authors are the same")
        else:
            print("Authors are different")


b1 = Book("Opekkha","Humayun Ahmed")
print(b1.get_price())
b1.update_price(250)
print(b1.get_price())
print("------------------------------------------")
b1.details()
print("-------------------------------------------")
b2 = Book("Deyal","Humayun Ahmed")
b2.update_price(300)
b2.details()
print("-------------------------------------------")
b1.compare(b2)  # Here we pass the other object as parameter

# In case tester file and design file in different directory
# from folder_name import class_file_name
# b2= class_file_name.Book("x","y")

class Cat:
    def __init__(self, color, action):
        self.color = color
        self.action = action
    def view(self,num,clr):
        num=num+5
        clrl=clr
        clrl[0] = "Green"
        print("Inside method: value=", num)
        print("Inside method: list=",clrl)

c1= Cat("White","Jump")
colors=["Black","Blue","White"]
x= 55
c1.view(x,colors)  #only "value" of x and "location" of the list colors is passed
print("Outside method: value=",x)  # Didn't update cause "passed by value"
print("outside method: List=",colors) # updated cause "passed by reference"

# Method overloading - methods with same name and different parameters

class calc:
    def sum(self,n1,n2=None,n3=None):
        if n2==None and n3==None:
            sum=n1
        elif n2==None:
            sum=n1+n3
        elif n3==None:
            sum=n1+n2
        else:
            print(n1,n2,n3)
            sum=n1+n2+n3
        print(sum)

    def ez_sum(self,n1,n2=0,n3=0):
        print(n1+n2+n3)

    def SUM(self,*nums):  #variable parameters
        print(nums)
        sum=0
        for i in nums:
            sum+=i
        print(sum)

# we can use dispatch to avoid method overloading as well
c1=calc()
c1.sum(4)
c1.sum(4,5)
c1.sum(4,5,6)
print("-------------------------------")
c1.ez_sum(4,5)
print("-------------------------------")
c1.SUM(5,6)

# How to achieve constructor overloading

class Student:
    def __init__(self,*info):  # **info for dictionary/keyword based
        if len(info)==3:
            self.name =info[0]
            self.id = info[1]
            self.cgpa=info[2]
        elif len(info)==2:
            self.name =info[0]
            self.id = info[1]
        print(info)
s1=Student("Ahil",20,3.5)
s2=Student("Arabi",10)

# Pass by reference
class Student:
    def __init__(self,name,id):
        self.name=name
        self.id=id

class dummy:
    def __init__(self):
        self.val=0
    def detail(self,std):
        print(std)
        print(std.name)
        print(std.id)

s1=Student("Bob",20)
d1=dummy()

#d1.detail(s1.name)  #
d1.detail(s1)

# Static method (Mehtods that do not use self parameter - work at class level, doesnt need object)

class Student:
    def __init__(self,name,id):
        self.name=name
        self.id=id
    @staticmethod # Decorator
    def college():
        print("Any college")

s1=Student("Arabi",5209)
s1.college()   # would give error if we didnt use staticmethod

"""# Pillars of OOP
*   Abstraction - Hiding the implementation details of a class and showing only essential features to user
*   Encapsulation -  wrapping data and fuctions into a single unit (object)
*   Inheritance - Child/Derived class derives the properties of another parent/Base class
*   Polymorphism - same operator is allowed to have different meaning according to the context


"""

# Private(like) attributes or methods (Cannot be accessed outside the class)

class Account:
    def __init__(self,name, password):
        self.name = name
        self.__pass = password  # Private attribute
    def reset_pass(self):
        print(self.__pass)

    def __hello(self):  # Private method
        print("Hello",self.name)
    def welcome(self):
        self.__hello()

acc1 = Account("Ahil","JH56")
acc1.reset_pass()
print(acc1.name)
#print(acc1.__pass)

acc1.welcome()
#acc1.__hello()

# Single Inheritance

class Car:
    color="Black"
    @staticmethod
    def start():
        print("Car Started")

    def stop(self):
        print("Car Stopped")

class ToyotaCar(Car):
    def __init__(self,name):
        self.name=name

car1 = ToyotaCar("Fortuner")
car2 = ToyotaCar("Prius")
print(car1.name)
car1.start()   #ToyotaCar inherited start method from Car
car2.stop()
print(car1.color)

# Multi-level Inheritance

class Car:
    color="Black"
    @staticmethod
    def start():
        print("Car Started")

    def stop(self):
        print("Car Stopped")

class ToyotaCar(Car):
    def __init__(self,name):
        self.name=name

class Fortuner(ToyotaCar):
    def __init__(self,type):
        self.type = type

car1 = Fortuner("diesel")
print(car1.type)
car1.stop()  # stop method: Car -> ToyotaCar -> Fortuner

# Multiple Inheritance - Inheriting from multiple parent class

class Car1:
    def __init__(self,ctype):
        self.ctype = ctype
    def start(self):
        print(self.name, "Started")
    def stop(self):
        print(self.name, "Stopped")

class Car2:
    def move(self):
        print(self.name, "Moving")

class Car(Car1,Car2):
    def __init__(self,name,ctype):
        self.name = name
        super().__init__(ctype)  # Passing the value to Car1
        super().stop()  # calling method from Car1 class

new_car = Car("Fortuner","Electric")
print(new_car.name)
new_car.start() # Inherited from Car1
new_car.move() # Inherited from Car2
print(new_car.ctype)

# Changing the value of class attribute

class Person:
    name = "anonymous"

    def changeName(self,name):
        self.name = name  # Doesnt change the value of Person.name
        Person.name = name
        #self.__class__.name = name  # Another way
p1 = Person()
p1.changeName("Ahil")
print(p1.name)
print(Person.name)

# Class Method

class Person:
    name = "anonymous"

    @classmethod
    def changeName(cls,name):
        cls.name = name  # changes the value of Person.name
p1 = Person()
p1.changeName("Ahil")
print(p1.name)
print(Person.name)

class Student:
    def __init__(self,phy,chem,math):
        self.phy=phy
        self.chem=chem
        self.math=math
    @property   # returns the value as an attribute as the method name (percentage returned as an attribute)
    def percentage(self):
        return str((self.phy + self.chem + self.math)/3) + "%"

st1=Student(98,97,99)
print(st1.percentage)
st1.phy=86
print(st1.percentage)

# Polymorphism (Operator overloading - same operator may have different meaning in different context)
# For example, "+" can be used for addition, concatenation, merge